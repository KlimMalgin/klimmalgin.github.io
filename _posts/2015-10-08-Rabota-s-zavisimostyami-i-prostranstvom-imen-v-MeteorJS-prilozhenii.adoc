# Работа с зависимостями и пространством имен в MeteorJS-приложении

:hp-tags: JavaScript, MeteorJS, Application, Namespace


Случилась у меня недавно необходимость писать приложение на Meteor. Так как с фреймворком я был знаком очень поверхностно, но имел на него виды - взялся с энтузиазмом.

Начал, как водится, с чтения доков. Первая же, и пока, единственная вещь, которая насторожила меня в Meteor'e, это проядок загрузки файлов, который в общем случае происходит в алфавитном порядке.

Для меня это проблема, т.к. структуру приложения делаю компонентную, а Meteor на это добросовестно кладет. Подгонять имена компонент и файлов под специфику фреймворка мне показалось не лучшим решением, поэтому написал небольшой инструмент для удобства работы с JS-модулями исходя из того, что они могут быть загружены в хаотичном порядке.

Репозиторий проекта: https://github.com/KlimMalgin/NamespaceJS

Как он работает смотрим дальше.

#### Идея

Идея NamespaceJS предельно проста. Она состоит в том, чтобы:

- Работать с модулями, обращаясь к ним через неймспейсы;
- Иметь возможность перебрать содержимое какого-либо неймспейса (например, чтобы инициализировать находящиеся в нем модули);

Чтобы начать работу - нужно инициализировать NamespaceJS:

```
NamespaceInit('Root');

```

В качестве параметра в NamespaceInit передаем название нашего корневого неймспейса. Можно ничего не передавать, тогда по умолчанию он будет называться App. Код выше создаст объект window.Root.


Теперь, когда у нас есть базовый неймспейс, можем создать пару модулей.

File /modules/myModule1.js
```
Root.ns('modules.myModule1', {
    startup: function () {
        // initialize function
    },

    dbg: function(){
        console.info('myModule1::DEBUG::');
    }
});

```

File /modules/myModule2.js
```
Root.ns('modules.myModule2', {
    startup: function () {
        // initialize function
    },

    method: function(){
        console.info('myModule2::DEBUG::');
    }
});

```

Таким образом мы получили следующую структуру:

```
window.Root = {
	modules: {
    	myModule1: {...},
        myModule2: {...}
    }
};

```

Метод ns получает path-строку вида "modules.myModule2". Он делает на ней split, получает массив уровней нужной структуры, проверяет наличие каждого из уровней и если какого-то из них нет - создает. Последним уровнем будет то, что передано в ns вторым параметром.





